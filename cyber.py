from datetime import datetime
from urllib.parse import quote
import requests
import time
import json
import pyExploitDb
from datetime import datetime
from pyExploitDb import PyExploitDb
from urllib.parse import quote
import sys
from urllib.parse import unquote

if sys.version_info[0] < 3:
    raise Exception("Use Python 3:  python3 " + sys.argv[0])
import re


#Parameters
report_filename = ""
pEdb = PyExploitDb()
edb = PyExploitDb()

def fetch_cve_details(cve_id):
    """Fetches details for a given CVE ID from the CVE API."""

    cve_url = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve_id}"
    try:
        response = requests.get(cve_url)
        response.raise_for_status()  # Raise an exception for bad status codes
        data = response.json()

        # Extract relevant details (adjust based on actual API response)
        cve_details = {
            'cve_id': cve_id,
            'description': data['result']['CVE_Items'][0]['cve']['description']['description_data'][0]['value'],
            'severity': data['result']['CVE_Items'][0]['impact']['baseMetricV3']['cvssV3']['baseSeverity'] 
            # Add more details as needed
        }
        return cve_details

    except requests.exceptions.RequestException as e:
        print(f"Error fetching CVE details for {cve_id}: {e}")
        return {'cve_id': cve_id, 'description': 'Error fetching details', 'severity': 'Unknown'}


def check_vulnerability(target_url, vulnerability_type):
    """Performs specific vulnerability checks."""

    # Add the 'http://' scheme if it's missing
    if not target_url.startswith('http://') and not target_url.startswith('https://'):
        target_url = 'http://' + target_url

    # Check if the target URL is a local IP address
    is_local_ip = target_url.startswith('http://10.') or target_url.startswith('http://192.168.') or target_url.startswith('http://172.16.')

    if not is_local_ip:
        confirm = input(f"The target URL ({target_url}) appears to be a local IP address. Are you sure you want to scan it? (yes/no): ")
        if confirm.lower() != 'yes':
            return None, None, None  # Skip the scan if not confirmed

    try:
        if vulnerability_type == 'sql_injection':
            # List of SQL injection payloads
            payloads = [
                "' OR 1=1--",
                "' UNION SELECT 1,2,3--",
            ]

            for payload in payloads:
                response = requests.get(target_url, params={'param': payload})

                # Check for error messages
                if "error" in response.text.lower() or response.status_code != 200:
                    severity = "High"
                    remediation = "Sanitize and parameterize all user input before using it in SQL queries. Consider using prepared statements or ORM libraries to prevent SQL injection."
                    return "SQL Injection (Error-based)", severity, remediation

            # Time-based blind SQL injection 
            time_based_payload = "' AND SLEEP(5)--"  # Adjust sleep duration as needed
            start_time = time.time()
            response = requests.get(target_url, params={'param': time_based_payload})
            end_time = time.time()

            if (end_time - start_time) > 4:  # Adjust threshold based on network latency
                severity = "High"
                remediation = "Sanitize and parameterize all user input before using it in SQL queries. Consider using prepared statements or ORM libraries to prevent SQL injection."
                return "SQL Injection (Time-based Blind)", severity, remediation

            # Blind SQL injection (boolean-based)
            true_payload = "' OR '1'='1"
            false_payload = "' OR '1'='2"

            true_response = requests.get(target_url, params={'param': true_payload})
            false_response = requests.get(target_url, params={'param': false_payload})

            if true_response.text != false_response.text:
                severity = "High"
                remediation = "Sanitize and parameterize all user input before using it in SQL queries. Consider using prepared statements or ORM libraries to prevent SQL injection."
                return "SQL Injection (Blind - Boolean-based)", severity, remediation

        elif vulnerability_type == 'xss':
            # List of XSS payloads (include different contexts and encodings)
            payloads = [
                "<script>alert('XSS Vulnerable')</script>",
                "<img src=x onerror=alert('XSS Vulnerable')>",
                "%3Cscript%3Ealert%28%27XSS%20Vulnerable%27%29%3C%2Fscript%3E",  # URL-encoded
                # ... (Add more payloads as needed)
            ]

            # Test different parameters or input fields (if applicable)
            params_to_test = ['param', 'query', 'search', 'name']  # Adjust based on target URL

            for payload in payloads:
                for param in params_to_test:
                    response = requests.get(target_url, params={param: payload})

                    # Check if the payload is reflected in the response (unescape for better detection)
                    if unquote(payload) in response.text:
                        severity = "Medium" 
                        remediation = "Properly encode and sanitize all user input before displaying it on the page. Use a Content Security Policy (CSP) to further restrict script execution."
                        return "Cross-Site Scripting (XSS)", severity, remediation

        elif vulnerability_type == 'command_injection':
            # Test for command injection (this is a simplified example, real-world checks are more complex)
            payload = "; ls"  # Attempt to execute a basic command
            response = requests.get(target_url, params={'cmd': payload})  # Use params for the payload

            #response = requests.get(target_url + payload)

            # Check for unexpected output or behavior in the response
            if "index.html" in response.text or response.status_code != 200: 
                severity = "Critical" 
                remediation = "Never directly execute user input as part of a system command. Use proper sanitization and escaping techniques."
                return "Command Injection", severity, remediation

        elif vulnerability_type in ('directory_traversal', 'file_inclusion'):
            # Common traversal payloads 
            payloads = [
                '../etc/passwd',
                '../../../../etc/passwd',
                '/etc/passwd',
                '../../../../../../../../../../../../../../../../../etc/passwd',
                '\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\boot.ini', 
                '/boot.ini',
                '\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\boot.ini', 
                '\\\\..\\\\..\\\\..\\\\windows\\\\win.ini',
                '/windows/win.ini',
                '\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\windows\\\\win.ini'
                # ... (Add more payloads as needed)
            ]

            for payload in payloads:
                # URL-encode the payload 
                encoded_payload = quote(payload)

                # Make the request with the payload in the query parameter
                response = requests.get(target_url, params={'page': encoded_payload}) 

                # Check for indicators of successful traversal/inclusion
                if "root:" in response.text or "boot loader" in response.text:
                    severity = "High"
                    remediation = "Properly sanitize and validate user input before using it in file paths or includes. Use whitelisting or other secure input handling techniques."
                    return f"{vulnerability_type.capitalize()} Vulnerability", severity, remediation
                

        elif vulnerability_type == 'csrf':
            # Look for common CSRF protection mechanisms in forms or headers
            response = requests.get(target_url)  # Fetch the page
            # Check for CSRF tokens in forms
            if re.search(r'<input.*name=["\']csrf_token["\']', response.text, re.IGNORECASE) or \
               re.search(r'<input.*name=["\']_csrf["\']', response.text, re.IGNORECASE):
                return None, None, None  # Basic protection seems to be present

            # Check for CSRF tokens in headers
            if "csrf_token" in response.headers or "xsrf-token" in response.headers:
                return None, None, None

            severity = "Medium"
            remediation = "Implement CSRF tokens for all state-changing requests. Consider using libraries or frameworks that provide built-in CSRF protection."
            return "Potential CSRF Vulnerability (No obvious protection)", severity, remediation
        
        elif vulnerability_type == 'idor':
            # Test for IDOR by manipulating parameters (not just numeric IDs)
            params_to_test = ['id', 'user', 'file']  # Adjust based on target URL

            for param in params_to_test:
                if param in target_url:
                    original_value = re.search(rf'{param}=(\w+)', target_url).group(1)
                    modified_value = 'test'  # Or any other value different from original_value

                    modified_url = re.sub(rf'{param}={original_value}', f'{param}={modified_value}', target_url)
                    original_response = requests.get(target_url)
                    modified_response = requests.get(modified_url)

                    # Check for unauthorized access or unexpected differences in responses
                    if original_response.status_code != modified_response.status_code or \
                       (original_response.status_code == 200 and original_response.text != modified_response.text):
                        severity = "High"
                        remediation = "Implement proper access controls and authorization checks to prevent unauthorized access to sensitive data. Avoid relying solely on user-supplied identifiers."
                        return "Potential IDOR Vulnerability", severity, remediation
        
        elif vulnerability_type == 'clickjacking':
            # Check for X-Frame-Options header
            response = requests.get(target_url)
            if 'X-Frame-Options' in response.headers:
                return None, None, None  # X-Frame-Options is present
            else:
                severity = "Medium"
                remediation = "Set the X-Frame-Options header to 'DENY' or 'SAMEORIGIN' to prevent clickjacking attacks."
                return "Potential Clickjacking Vulnerability (No X-Frame-Options)", severity, remediation            
        # ... (Add more vulnerability types as needed)

        elif vulnerability_type == 'outdated_software':
        # Attempt to identify web server and technologies using banner grabbing or other techniques
                response = requests.get(target_url)
                server_header = response.headers.get('Server') 

                if server_header:
                # Example: Check for outdated Apache version
                    if "Apache" in server_header:
                        version_match = re.search(r'Apache/([\d.]+)', server_header)
                        if version_match:
                            version = version_match.group(1)
                            # Check against a vulnerability database or known outdated versions
                            if is_outdated("Apache", version):
                                severity = "High"
                                remediation = "Update Apache to the latest stable version."
                                return "Outdated Apache Server", severity, remediation

        # ... (Add checks for other technologies like CMS, frameworks, etc.)
        elif vulnerability_type == 'rce':
            # List of potential RCE patterns in URLs or parameters
            rce_patterns = [
                'eval(', 
                'exec(', 
                'system(', 
                'passthru(', 
                'shell_exec(', 
                'popen(', 
                'proc_open(', 
                'pcntl_exec(',
                'assert(',
                'preg_replace(/e',
                'create_function(',
                '$_GET',
                '$_POST',
                '$_REQUEST',
                '$_COOKIE'
                # Add more patterns as needed
            ]

            # Check if any of the patterns are present in the target URL
            for pattern in rce_patterns:
                if pattern in target_url.lower():
                    severity = "Critical"
                    remediation = "Thoroughly review and sanitize all user input before using it in any dynamic code execution context. Avoid using eval(), exec(), and similar functions whenever possible. Consider using safer alternatives or parameterized functions."
                    return "Potential RCE Vulnerability (Pattern-based)", severity, remediation

            # If no obvious patterns found, try a basic command injection attempt
            # (similar to the existing command injection check)
            payload = "; ls"
            response = requests.get(target_url, params={'cmd': payload})  # Use params for the payload
 
            #response = requests.get(target_url + payload)

            # Check for unexpected output or behavior in the response
            if "index.html" in response.text or response.status_code != 200:
                severity = "Critical"
                remediation = "Thoroughly review and sanitize all user input before using it in any dynamic code execution context. Avoid using eval(), exec(), and similar functions whenever possible. Consider using safer alternatives or parameterized functions."
                return "Potential RCE Vulnerability (Command Injection Attempt)", severity, remediation

        # If no RCE indicators found, return None
        #return None, None, None

        elif vulnerability_type == 'security_misconfiguration':
            # Check for verbose error messages
            try:
                response = requests.get(target_url + "/nonexistent_page")  # Trigger a 404 error
                if "stack trace" in response.text.lower() or \
                   "database error" in response.text.lower() or \
                   re.search(r'\b(warning|error|exception)\b', response.text, re.IGNORECASE):
                    severity = "Medium"
                    remediation = "Configure your web server and application to display generic error messages to users. Avoid revealing sensitive information like stack traces or database errors."
                    return "Verbose Error Messages", severity, remediation
            except requests.exceptions.RequestException:
                pass  # Ignore connection errors for this check

            # Check for directory listing
            try:
                response = requests.get(target_url + "/uploads/")  # Adjust the directory path as needed
                if "Index of /uploads/" in response.text:
                    severity = "Low"  # Severity might vary depending on exposed content
                    remediation = "Disable directory listing on your web server."
                    return "Directory Listing Enabled", severity, remediation
            except requests.exceptions.RequestException:
                pass 

            # Check for default files/paths
            default_paths = ['/phpmyadmin/', '/admin/', '/examples/', '/test/']  # Add more as needed
            for path in default_paths:
                try:
                    response = requests.get(target_url + path)
                    if response.status_code == 200:
                        severity = "Medium"
                        remediation = f"Remove or restrict access to default paths like '{path}'."
                        return f"Default Path Accessible: {path}", severity, remediation
                except requests.exceptions.RequestException:
                    pass

        elif vulnerability_type == 'csrf':
            # Look for common CSRF protection mechanisms in forms or headers
            response = requests.get(target_url)

            # Check for CSRF tokens in forms
            if re.search(r'<input.*name=["\']csrf_token["\']', response.text, re.IGNORECASE) or \
                re.search(r'<input.*name=["\']_csrf["\']', response.text, re.IGNORECASE):
                return None, None, None  # Basic protection seems to be present

            # Check for CSRF tokens in headers
            if "csrf_token" in response.headers or "xsrf-token" in response.headers:
                return None, None, None

            severity = "Medium"
            remediation = "Implement CSRF tokens for all state-changing requests. Consider using libraries or frameworks that provide built-in CSRF protection."
            return "Potential CSRF Vulnerability (No obvious protection)", severity, remediation
        
 
    except requests.exceptions.RequestException as e:
            print(f"Error connecting to {target_url}: {e}")
            return None, None, None

    return None, None, None

def is_outdated(software, version):
    """Checks if a software version is outdated (placeholder)."""

    # Implement logic to check against a vulnerability database or list of known outdated versions
    # You might need to use an external API or maintain a local database

    # For now, let's just assume any version below 2.4.50 is outdated for Apache
    if software == "Apache" and version < "2.4.50":
        return True
    else:
        return False
   

def assess_severity(vulnerability_type, context=None):
    """Assesses the severity of the identified vulnerability based on type and context."""

    # Basic severity mapping
    severity_map = {
        'sql_injection': 'High',
        'xss': 'Medium',
        'command_injection': 'Critical',
        'directory_traversal': 'High',
        'file_inclusion': 'High',
        # ... add more mappings as needed
    }

    severity = severity_map.get(vulnerability_type, 'Unknown')

    # Context-based adjustments (examples)
    if context:
        if vulnerability_type == 'xss' and "admin" in context.lower():
            severity = 'Critical'  # XSS in admin panel is more severe
        elif vulnerability_type == 'directory_traversal' and "/etc/passwd" in context:
            severity = 'Critical'  # Accessing /etc/passwd is critical

    return severity

def suggest_remediation(vulnerability_type):
    """Suggests potential remediation steps for the vulnerability."""

    remediation_map = {
        'sql_injection': "Sanitize and parameterize all user input before using it in SQL queries. Consider using prepared statements or ORM libraries to prevent SQL injection.",
        'xss': "Properly encode and sanitize all user input before displaying it on the page. Use a Content Security Policy (CSP) to further restrict script execution.",
        'command_injection': "Never directly execute user input as part of a system command. Use proper sanitization and escaping techniques. Consider using libraries or functions designed for safe command execution.",
        # Add more mappings as needed
    }
    return remediation_map.get(vulnerability_type, "Consult security best practices for this vulnerability type.")


def check_exploit_db(vulnerability_type):
    """Queries the Exploit Database for known exploits."""

    edb = PyExploitDb()

    # Search for exploits related to the vulnerability type (using searchCve)
    exploits = edb.searchCve(vulnerability_type)

    # Process the results (extract relevant info, filter, etc.)
    relevant_exploits = []
    for exploit in exploits:
        # Example: Extract exploit title and URL
        relevant_exploits.append({
            'title': exploit.title,
            'url': exploit.url
        })

    return relevant_exploits

# ... (check_vulnerability, assess_severity, suggest_remediation, check_exploit_db functions - same as before)

def generate_report(target_url, vulnerabilities):
    """Generates an HTML report of the scan results."""

    global report_filename
    report_filename = f"vulnerability_report_{target_url}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.html"

    with open(report_filename, 'w') as f:
        # Write the initial part of the HTML (up to the Vulnerability Summary table)
        f.write(f"""
<!DOCTYPE html>
<html>
<head>
<title>Vulnerability Scan Report</title>
<style>
body {{ font-family: sans-serif; }}
h2, h3 {{ color: #333; }}
table {{ border-collapse: collapse; width: 100%; }}
th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
th {{ background-color: #f2f2f2; }}
.critical {{ color: red; }}
.high {{ color: orange; }}
.medium {{ color: #f4d03f; }} /* Yellow */
.low {{ color: #2ecc71; }} /* Green */
</style>
</head>
<body>
<h2>Vulnerability Scan Report</h2>

<h3>Target Information</h3>
<table>
<tr><th>URL</th><td>{target_url}</td></tr>
<tr><th>Scan Date</th><td>{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</td></tr>
<tr><th>Scanner Version</th><td>1.0 (Basic)</td></tr>
</table>

<h3>Vulnerability Summary</h3>
<table>
<tr><th>Severity</th><th>Count</th></tr>
""")

        # Add logic to populate severity counts here 
        severity_counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Unknown': 0}
        for _, severity, _ in vulnerabilities:
            severity_counts[severity] += 1

        for severity, count in severity_counts.items():
            f.write(f"<tr><td>{severity}</td><td>{count}</td></tr>\n")

        # Write the start of the Detailed Vulnerability Reports table
        f.write("""
</table>

<h3>Detailed Vulnerability Reports</h3>
<table>
<tr><th>Vulnerability</th><th>Severity</th><th>Remediation</th><th>Potential Exploits/CVEs</th></tr>
""")

        # Now iterate and write each vulnerability row dynamically
        for vuln_type, severity, remediation in vulnerabilities:
            f.write(f"""<tr>
<td class="{severity.lower()}">{vuln_type}</td>
<td class="{severity.lower()}">{severity}</td>
<td>{remediation}</td>
<td>""")

            exploits = check_exploit_db(vuln_type)
            if exploits:
                for exploit in exploits:
                    if 'cve_id' in exploit:
                        f.write(f"<li>CVE-{exploit['cve_id']}: {exploit['description']} (Severity: {exploit['severity']})</li>")
                    else:
                        f.write(f"<li>{exploit['title']} (<a href='{exploit['url']}' target='_blank'>{exploit['url']}</a>)</li>")

            f.write("</td></tr>\n")

        # Write the closing parts of the HTML
        f.write("""
</table>

<h3>Conclusion</h3>
<p>...</p>  </body>
</html>
""")

# Get target URL and scan types from the user
target_url = input("Enter the target URL: ")

# Display available commands
print("\nAvailable Vulnerability Checks:")
print("- sql_injection")
print("- xss")
print("- command_injection")
print("- csrf")
print("- idor")
print("- clickjacking")
print("- outdated_sof")
print("- rce")
print("- security_misconfiguration")
# Add more commands as you implement additional checks

scan_types = input("Enter comma-separated vulnerability types to check: ").split(',')

# Perform vulnerability checks
vulnerabilities = []
for vulnerability_type in scan_types:
    result = check_vulnerability(target_url, vulnerability_type)
    if result[0]:
        vulnerabilities.append(result)

# Generate the report
generate_report(target_url, vulnerabilities)

print(f"Scan complete! Report saved to {report_filename}")
